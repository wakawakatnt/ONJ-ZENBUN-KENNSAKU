<!doctype html>
<html lang="ja">
<head>
<meta charset="utf--8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ONJ 掲示板データ検索</title>
<style>
  body { font-family: system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo,Arial; margin: 18px; line-height: 1.5; background-color: #f4f4f9; color: #333; }
  input { padding: 10px; width: 70%; margin-right: 10px; border-radius: 6px; border: 1px solid #ccc; font-size: 1em; }
  button { padding: 10px 18px; border: none; border-radius: 6px; background-color: #1976d2; color: white; cursor: pointer; font-size: 1em; }
  button:hover { background-color: #1565c0; }
  button:disabled { background-color: #ccc; cursor: not-allowed; }
  #clearBtn { background-color: #757575; }
  #clearBtn:hover { background-color: #616161; }
  #docsBtn { background-color: #4caf50; }
  #docsBtn:hover { background-color: #45a049; }
  #shareBtn { background-color: #ff9800; }
  #shareBtn:hover { background-color: #f57c00; }
  #refreshBtn { background-color: #9c27b0; }
  #refreshBtn:hover { background-color: #7b1fa2; }
  .controls { margin-bottom: 20px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
  .info { background: #e3f2fd; padding: 12px; margin-bottom: 20px; border-radius: 6px; border-left: 5px solid #1976d2; }

  /* 読み込み設定 */
  .load-settings { background: #fff; border: 1px solid #ddd; border-radius: 6px; padding: 12px; margin-bottom: 20px; }
  .load-settings h3 { margin: 0 0 10px 0; font-size: 1.1em; color: #1976d2; }
  .load-options { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
  .load-options label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
  .load-options input[type="radio"] { margin: 0; }
  .load-options input[type="number"] { width: 80px; padding: 5px; margin: 0 5px; border: 1px solid #ccc; border-radius: 4px; }
  .status-info { margin-top: 10px; font-size: 0.9em; color: #666; }

  /* 検索オプション */
  .search-options-wrapper { display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px; }
  .search-type-options, .sort-options { background: #fff; border: 1px solid #ddd; border-radius: 6px; padding: 12px; }
  .search-type-options label, .sort-options label { margin-right: 20px; display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
  .search-type-options input[type="radio"], .sort-options input[type="radio"] { margin-right: 5px; }
  .sort-options { display: none; } /* 初期状態は非表示 */

  /* ドキュメント一覧のスタイル */
  .documents-list { background: #fff; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; display: none; }
  .documents-header { padding: 15px; background: #f5f5f5; border-bottom: 1px solid #ddd; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
  .document-item { padding: 12px 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: background-color 0.2s; }
  .document-item:hover { background: #f9f9f9; }
  .document-item:last-child { border-bottom: none; }
  .document-name { font-weight: 500; color: #1976d2; }
  .document-info { display: flex; gap: 15px; font-size: 0.9em; color: #666; }
  .document-size { font-weight: bold; }
  .document-stats { font-size: 0.8em; }
  .active-document { background: #e8f5e8; }

  /* スレッド検索結果のスタイル */
  .thread-result { border: 1px solid #ddd; border-radius: 8px; margin-bottom: 12px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
  .thread-header { padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; gap: 15px; }
  .thread-header:hover { background: #f5f5f5; }
  .thread-title-wrapper { flex-grow: 1; min-width: 0; }
  .thread-title { font-weight: bold; color: #1976d2; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .thread-stats { text-align: right; flex-shrink: 0; }
  .total-posts { font-size: 0.85em; color: #666; display: block; }
  .match-count { font-size: 0.9em; color: #c0392b; font-weight: bold; }
  .document-source { font-size: 0.8em; color: #888; font-style: italic; }
  .last-updated { font-size: 0.8em; color: #666; margin-top: 2px; }
  
  .thread-details { display: none; padding: 0 15px 15px; border-top: 1px solid #eee; }
  .thread-meta { padding: 12px 0; font-size: 0.95em; }
  .thread-meta a { color: #007bff; text-decoration: none; }
  .thread-meta a:hover { text-decoration: underline; }
  
  /* レスのスタイル */
  .post { border-top: 1px dashed #ccc; padding: 12px 0; }
  .post:first-child { border-top: none; }
  .post-meta { font-size: 0.9em; color: #555; margin-bottom: 8px; }
  .post-meta strong { color: #008000; }
  .post-content { white-space: pre-wrap; line-height: 1.6; background: #fafafa; padding: 10px; border-radius: 4px; word-wrap: break-word; }
  .highlight { background-color: #ffeb3b; padding: 1px 2px; border-radius: 2px; }

  /* 検索結果サマリー */
  .search-summary { background: #fff3cd; border: 1px solid #ffeaa7; padding: 12px; border-radius: 6px; margin-bottom: 20px; }
  .search-summary strong { color: #856404; }

  /* ローディング表示 */
  .loading { text-align: center; padding: 40px; color: #666; }
  .loading::after { content: ''; display: inline-block; width: 20px; height: 20px; border: 2px solid #ddd; border-radius: 50%; border-top-color: #1976d2; animation: spin 1s ease-in-out infinite; margin-left: 10px; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* レスポンシブ対応 */
  @media (max-width: 768px) {
    .controls { flex-direction: column; align-items: stretch; }
    input { width: 100%; margin-right: 0; margin-bottom: 10px; }
    .document-item { flex-direction: column; align-items: flex-start; gap: 8px; }
    .document-info { flex-direction: column; gap: 5px; }
    .search-type-options label, .sort-options label { display: block; margin-bottom: 8px; }
    .load-options { flex-direction: column; align-items: flex-start; }
  }
</style>
</head>
<body>
<h2>ONJ 掲示板データ検索システム</h2>

<div class="controls">
  <input type="text" id="searchInput" placeholder="検索ワード（名前、ID、投稿内容）">
  <button id="searchBtn">検索</button>
  <button id="clearBtn">クリア</button>
  <button id="docsBtn">ドキュメント一覧</button>
  <button id="shareBtn">URL共有</button>
  <button id="refreshBtn">データ再更新</button>
</div>

<div class="load-settings">
  <h3>データ読み込み設定</h3>
  <div class="load-options">
    <label>
      <input type="radio" name="loadMode" value="latest" checked> 最新
      <input type="number" id="latestCount" min="1" max="100" value="10" style="width: 60px;">件
    </label>
    <label>
      <input type="radio" name="loadMode" value="all"> すべて読み込む
    </label>
  </div>
  <div class="status-info" id="loadStatus">
    まだデータを読み込んでいません。検索ボタンを押してデータを読み込んでください。
  </div>
</div>

<div class="search-options-wrapper">
  <div id="searchTypeOptions" class="search-type-options">
    <strong>検索範囲:</strong>
    <label>
      <input type="radio" name="searchType" value="all" checked> 全て
    </label>
    <label>
      <input type="radio" name="searchType" value="title"> スレタイのみ
    </label>
    <label>
      <input type="radio" name="searchType" value="body"> 本文のみ (名前, ID, 投稿内容)
    </label>
  </div>

  <div id="sortOptions" class="sort-options">
    <strong>結果の並び順:</strong>
    <label>
      <input type="radio" name="sortOrder" value="newest" checked> 最新順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="oldest"> 古い順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="document"> ドキュメント名順
    </label>
    <label>
      <input type="radio" name="sortOrder" value="relevance"> 関連度順
    </label>
  </div>
</div>

<div id="documentsList" class="documents-list">
  <div class="documents-header">
    <span>読み込み済みドキュメント一覧</span>
    <span id="documentsCount"></span>
  </div>
  <div id="documentsContent"></div>
</div>

<div id="info" class="info">検索ボタンを押してデータを読み込み、検索を開始してください。</div>
<div id="searchSummary" class="search-summary" style="display: none;"></div>
<div id="results"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, getDoc, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
  
  const firebaseConfig = {
    apiKey: "AIzaSyA2Z-JByRuaSv88nAj356nOh4CNgQb0_SY",
    authDomain: "onj-zenbun-kensaku.firebaseapp.com",
    projectId: "onj-zenbun-kensaku",
    storageBucket: "onj-zenbun-kensaku.firebasestorage.app",
    messagingSenderId: "171332002735",
    appId: "1:171332002735:web:c8dcad3ae133300900855a",
    measurementId: "G-DDHGB57HTW"
  };
  
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  let loadedDocuments = [];
  let loadedDocumentThreads = new Map(); // ドキュメントID -> スレッドデータのマップ
  let currentSearchResults = []; // 現在の検索結果を保存
  let totalDocumentsAvailable = 0; // 利用可能なドキュメント総数
  let isDataLoaded = false; // データが読み込まれているかどうか

  function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  function parseDateTime(dateTimeStr) {
    if (!dateTimeStr) return null;
    
    // 日本のタイムゾーンで解析（例: "24/12/25(水) 15:30:45"）
    const match = dateTimeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\([^)]+\)\s+(\d{2}):(\d{2}):(\d{2})/);
    if (!match) return null;
    
    const [, year, month, day, hour, minute, second] = match;
    // 20XX年として扱う（例: 24 -> 2024）
    const fullYear = parseInt(year) + 2000;
    
    return new Date(fullYear, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second));
  }

  function parseContentData(content) {
    const threads = [];
    
    // =!=!=を使って分割（スレッド区切り）
    const threadParts = content.split(/=!=!=(\d+)=!=!=/);
    
    // 最初の空要素を削除
    if (threadParts[0] === '') {
      threadParts.shift();
    }
    
    // スレッドIDとコンテンツをペアで処理
    for (let i = 0; i < threadParts.length; i += 2) {
      const threadId = threadParts[i];
      const threadContent = threadParts[i + 1];
      
      if (!threadId || !threadContent) continue;
      
      // =?=?=で区切られたタイムスタンプ部分を削除
      const contentParts = threadContent.split('=?=?=');
      let cleanThreadContent = '';
      if (contentParts.length >= 3) {
        cleanThreadContent = contentParts.slice(2).join('=?=?=').trim();
      } else {
        cleanThreadContent = threadContent.trim();
      }
      
      if (!cleanThreadContent) continue;
      
      // 投稿を分割する正規表現を改善
      // 名前の開始パターン（「名無しさん」や特定の記号）の直前で分割する
      const postPattern = /(?=(?:名無しさん＠おーぷん|[▼▲★☆■]))/;
      let postStrings = cleanThreadContent.split(postPattern).filter(s => s.trim());
      
      if (postStrings.length === 0) continue;

      const posts = [];
      let threadTitle = "（タイトル不明）";
      let lastPostTime = null;

      postStrings.forEach((postStr, index) => {
        const postParts = postStr.split('<>');
        if (postParts.length < 3) return;

        const author = postParts[0].trim();
        let emailOrSage = postParts[1] || '';
        let dateTimeAndId = '';
        let postContent = '';
        
        // sageがある場合とない場合を判定
        if (postParts.length >= 4 && postParts[2].match(/\d{2}\/\d{2}\/\d{2}/)) {
          // sage有り: author<>sage<>datetime<>content
          dateTimeAndId = postParts[2];
          postContent = postParts.slice(3).join('<>');
        } else if (postParts.length >= 3 && postParts[1].match(/\d{2}\/\d{2}\/\d{2}/)) {
          // sage無し: author<>datetime<>content
          dateTimeAndId = postParts[1];
          postContent = postParts.slice(2).join('<>');
          emailOrSage = '';
        } else {
          return; // 形式が合わない場合はスキップ
        }

        // 最初の投稿からタイトルを抽出
        if (index === 0 && postContent) {
          let extractedTitle = '';
          
          // <> で分割して最後の部分を確認
          const contentTitleParts = postContent.split('<>');
          
          if (contentTitleParts.length > 1) {
            let candidateTitle = contentTitleParts[contentTitleParts.length - 1].trim();
            
            // タイトルと次の投稿の著者が結合している場合、分離する
            const ninjaPostStartIndex = candidateTitle.search(/[▼▲★☆■]/);
            if (ninjaPostStartIndex !== -1) {
                // 記号が見つかった場合、その手前までをタイトルとする
                candidateTitle = candidateTitle.substring(0, ninjaPostStartIndex).trim();
            }

            // HTMLタグを除去
            candidateTitle = candidateTitle.replace(/<[^>]+>/g, '').trim();
            
            // フォントタグなどの残骸を除去
            candidateTitle = candidateTitle.replace(/^[^>]*>/, '').trim();
            
            // 有効なタイトルかチェック
            if (candidateTitle && candidateTitle.length >= 3) {
              extractedTitle = candidateTitle;
              // タイトル部分を除いた内容を投稿内容とする
              postContent = contentTitleParts.slice(0, -1).join('<>').trim();
            }
          }
          
          // それでもタイトルが取れない場合、投稿内容の最初の行から推測
          if (!extractedTitle && postContent) {
            const firstLine = postContent.split('\n')[0].trim();
            const cleanFirstLine = firstLine.replace(/<[^>]+>/g, '').trim();
            
            if (cleanFirstLine.length >= 3 && cleanFirstLine.length <= 50 && !cleanFirstLine.match(/^https?:\/\//)) {
              extractedTitle = cleanFirstLine;
            }
          }
          
          if (extractedTitle) {
            threadTitle = extractedTitle;
          }
        }
        
        const idMatch = dateTimeAndId.match(/(\d{2}\/\d{2}\/\d{2}\([^)]+\) \d{2}:\d{2}:\d{2}) ID:\s*(\S+)/);
        if (idMatch) {
          const postTime = idMatch[1];
          const parsedTime = parseDateTime(postTime);
          if (parsedTime) {
            lastPostTime = parsedTime;
          }
          
          posts.push({
            postNumber: index + 1,
            author: author,
            sage: emailOrSage === 'sage',
            postTime: postTime,
            postTimeDate: parsedTime,
            userId: idMatch[2],
            content: postContent.replace(/<br>/g, '\n').trim()
          });
        }
      });
      
      if (posts.length > 0) {
        threads.push({
          id: threadId,
          title: threadTitle,
          link: `https://hayabusa.open2ch.net/test/read.cgi/livejupiter/${threadId}/`,
          posts: posts,
          lastUpdated: posts[posts.length - 1].postTime,
          lastUpdatedDate: lastPostTime
        });
      }
    }
    
    return threads;
  }

  async function fetchTotalDocuments() {
    try {
      const metaDocRef = doc(db, "meta", "document_count");
      const metaDocSnapshot = await getDoc(metaDocRef);
      
      if (metaDocSnapshot.exists()) {
        const data = metaDocSnapshot.data();
        totalDocumentsAvailable = data.totalDocuments || 0;
        return totalDocumentsAvailable;
      } else {
        console.warn("meta/document_count が見つかりません");
        return 0;
      }
    } catch (err) {
      console.error("総ドキュメント数の取得に失敗:", err);
      return 0;
    }
  }

  async function loadDocuments() {
    const keyword = document.getElementById('searchInput').value.trim();
    if (!keyword) {
      updateInfoPanel('<span style="color: #c0392b;">検索キーワードを入力してください。</span>');
      return;
    }

    const loadMode = document.querySelector('input[name="loadMode"]:checked').value;
    const latestCount = parseInt(document.getElementById('latestCount').value) || 10;

    // 検索ボタンを無効化
    const searchBtn = document.getElementById('searchBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    searchBtn.disabled = true;
    refreshBtn.disabled = true;
    
    try {
      // まず総ドキュメント数を取得
      await fetchTotalDocuments();
      
      document.getElementById('info').innerHTML = '<div class="loading">ドキュメントを読み込み中...</div>';
      document.getElementById('loadStatus').textContent = 'データを読み込み中...';
      
      let query_ref;
      let loadingMessage = '';
      
      if (loadMode === 'all') {
        query_ref = collection(db, "aggregated_threads");
        loadingMessage = `全${totalDocumentsAvailable}件のドキュメントを読み込み中...`;
      } else {
        query_ref = query(
          collection(db, "aggregated_threads"), 
          orderBy("__name__", "desc"), // ドキュメント名で降順ソート（最新順）
          limit(latestCount)
        );
        loadingMessage = `最新${latestCount}件のドキュメントを読み込み中...`;
      }
      
      document.getElementById('info').innerHTML = `<div class="loading">${loadingMessage}</div>`;
      
      const snapshot = await getDocs(query_ref);
      
      loadedDocuments = [];
      loadedDocumentThreads.clear();
      
      for (const docSnapshot of snapshot.docs) {
        const data = docSnapshot.data();
        const contentSize = data.content ? new Blob([data.content]).size : 0;
        const lastUpdated = data.lastUpdated ? new Date(data.lastUpdated.seconds * 1000).toLocaleString('ja-JP') : '不明';
        
        // データを解析してスレッド数と投稿数を計算
        const threads = parseContentData(data.content || '');
        loadedDocumentThreads.set(docSnapshot.id, threads);
        
        const threadCount = threads.length;
        const postCount = threads.reduce((sum, t) => sum + t.posts.length, 0);
        
        loadedDocuments.push({
          id: docSnapshot.id,
          name: docSnapshot.id,
          size: contentSize,
          lastUpdated: lastUpdated,
          threadCount: threadCount,
          postCount: postCount,
          data: data
        });
      for (const docInfo of docsToProcess) {
        // データを解析してスレッド数と投稿数を計算
        const threads = parseContentData(docInfo.data.content || '');
        loadedDocumentThreads.set(docInfo.id, threads);
        
        const threadCount = threads.length;
        const postCount = threads.reduce((sum, t) => sum + t.posts.length, 0);
        
        loadedDocuments.push({
          id: docInfo.id,
          name: docInfo.id,
          size: docInfo.contentSize,
          lastUpdated: docInfo.lastUpdated,
          threadCount: threadCount,
          postCount: postCount,
          data: docInfo.data
        });
      }
      
      // loadedDocumentsは既に最新順でソートされているので、名前順ソートはオプション
      // ドキュメント一覧では名前順で表示する場合は以下を有効化
      // loadedDocuments.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
      
      renderDocumentsList();
      isDataLoaded = true;
      
      // ステータス更新
      const loadedCount = loadedDocuments.length;
      const highestId = loadedDocuments.length > 0 ? loadedDocuments[0].id : '';
      const lowestId = loadedDocuments.length > 0 ? loadedDocuments[loadedDocuments.length - 1].id : '';
      
      const statusText = loadMode === 'all' 
        ? `全ドキュメント（${loadedCount}/${totalDocumentsAvailable}件）を読み込み完了`
        : `最新${loadedCount}件のドキュメントを読み込み完了（ID: ${highestId}〜${lowestId} | 全${totalDocumentsAvailable}件中）`;
      document.getElementById('loadStatus').textContent = statusText;
      
      // データ読み込み完了後に検索実行
      searchPosts();
      
    } catch (err) {
      document.getElementById('info').textContent = `エラー: ${err.message}`;
      document.getElementById('loadStatus').textContent = `読み込みエラー: ${err.message}`;
      console.error(err);
    } finally {
      // 検索ボタンを再度有効化
      searchBtn.disabled = false;
      refreshBtn.disabled = false;
    }
  }

  function renderDocumentsList() {
    const documentsContent = document.getElementById('documentsContent');
    const documentsCount = document.getElementById('documentsCount');
    
    documentsCount.textContent = `${loadedDocuments.length}件のドキュメント（全${totalDocumentsAvailable}件中）`;
    documentsContent.innerHTML = '';
    
    loadedDocuments.forEach(doc => {
      const docDiv = document.createElement('div');
      docDiv.className = 'document-item';
      
      docDiv.innerHTML = `
        <div class="document-name">${doc.name}</div>
        <div class="document-info">
          <span class="document-size">${formatBytes(doc.size)}</span>
          <span class="document-stats">スレッド: ${doc.threadCount}件, 投稿: ${doc.postCount}件</span>
          <span>更新: ${doc.lastUpdated}</span>
        </div>
      `;
      
      documentsContent.appendChild(docDiv);
    });
  }

  function toggleDocumentsList() {
    const docsList = document.getElementById('documentsList');
    const isHidden = docsList.style.display === 'none' || docsList.style.display === '';
    docsList.style.display = isHidden ? 'block' : 'none';
  }

  function updateInfoPanel(text = null) {
    if (text) {
        document.getElementById('info').innerHTML = text;
    } else if (isDataLoaded && loadedDocuments.length > 0) {
        const totalThreads = Array.from(loadedDocumentThreads.values()).reduce((sum, threads) => sum + threads.length, 0);
        const totalPosts = Array.from(loadedDocumentThreads.values()).reduce((sum, threads) => sum + threads.reduce((s, t) => s + t.posts.length, 0), 0);
        document.getElementById('info').innerHTML = `
          <strong>検索対象:</strong> 読み込み済みドキュメント (${loadedDocuments.length}/${totalDocumentsAvailable}件) | 
          <strong>総スレッド数:</strong> ${totalThreads} | 
          <strong>総投稿数:</strong> ${totalPosts}
        `;
    } else {
        document.getElementById('info').innerHTML = '検索ボタンを押してデータを読み込み、検索を開始してください。';
    }
  }

  function highlightSearchTerm(text, term) {
    if (!term || !text) return text;
    
    let termToHighlight = term;

    // "ID:"での検索かを判定（大文字小文字は区別しない）
    const idSearchMatch = term.match(/^id:\s*(.*)/i);
    if (idSearchMatch) {
        // ID検索の場合は、入力されたID部分（大文字小文字保持）をハイライト対象にする
        termToHighlight = idSearchMatch[1].trim().replace(/\s/g, '');
    }

    if (!termToHighlight) return text;

    // 特殊文字をエスケープ
    const escapedTerm = termToHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // gフラグ(全体)のみ使用し、大文字小文字を区別してハイライト
    const regex = new RegExp(`(${escapedTerm})`, 'g');
    
    return text.replace(regex, '<span class="highlight">$1</span>');
  }

  function sortSearchResults(results, sortOrder) {
    const sortedResults = [...results];
    
    switch (sortOrder) {
      case 'newest':
        sortedResults.sort((a, b) => {
          const dateA = a.lastUpdatedDate || new Date(0);
          const dateB = b.lastUpdatedDate || new Date(0);
          return dateB.getTime() - dateA.getTime();
        });
        break;
      case 'oldest':
        sortedResults.sort((a, b) => {
          const dateA = a.lastUpdatedDate || new Date(0);
          const dateB = b.lastUpdatedDate || new Date(0);
          return dateA.getTime() - dateB.getTime();
        });
        break;
      case 'document':
        sortedResults.sort((a, b) => {
          const nameA = a.documentName || '';
          const nameB = b.documentName || '';
          return nameA.localeCompare(nameB, undefined, {numeric: true});
        });
        break;
      case 'relevance':
        // 関連度順（マッチした投稿数でソート）
        sortedResults.sort((a, b) => b.matchedPosts.length - a.matchedPosts.length);
        break;
      default:
        break;
    }
    
    return sortedResults;
  }

  function renderSearchResults(results, keyword) {
    const resultsDiv = document.getElementById('results');
    const summaryDiv = document.getElementById('searchSummary');
    const sortOptionsDiv = document.getElementById('sortOptions');
    
    resultsDiv.innerHTML = '';

    if (results.length === 0) {
        resultsDiv.innerHTML = '<p>検索条件に一致するスレッドがありませんでした。</p>';
        summaryDiv.style.display = 'none';
        sortOptionsDiv.style.display = 'none';
        return;
    }

    // ソートオプションを表示
    sortOptionsDiv.style.display = 'block';

    // 検索結果サマリーを表示
    const totalMatches = results.reduce((sum, r) => sum + r.matchedPosts.length, 0);
    
    summaryDiv.innerHTML = `
      <strong>検索結果:</strong> "${keyword}" | 
      <strong>対象:</strong> ${loadedDocuments.length}/${totalDocumentsAvailable}ドキュメント | 
      <strong>ヒット:</strong> ${results.length}スレッド, ${totalMatches}投稿
    `;
    summaryDiv.style.display = 'block';

    results.forEach(thread => {
        const threadDiv = document.createElement('div');
        threadDiv.className = 'thread-result';

        const headerDiv = document.createElement('div');
        headerDiv.className = 'thread-header';
        headerDiv.innerHTML = `
            <div class="thread-title-wrapper">
                <span class="thread-title">${highlightSearchTerm(thread.title, keyword)}</span>
                ${thread.documentName ? `<div class="document-source">出典: ${thread.documentName}</div>` : ''}
                <div class="last-updated">最終更新: ${thread.lastUpdated}</div>
            </div>
            <div class="thread-stats">
                <span class="total-posts">全${thread.posts.length}レス</span>
                <span class="match-count">${thread.matchedPosts.length}件ヒット</span>
            </div>
        `;
        
        const detailsDiv = document.createElement('div');
        detailsDiv.className = 'thread-details';
        detailsDiv.innerHTML = `<div class="thread-meta">
            <a href="${thread.link}" target="_blank" rel="noopener noreferrer">このスレッドへのリンク</a>
        </div>`;

        thread.matchedPosts.forEach(post => {
            const postDiv = document.createElement('div');
            postDiv.className = 'post';
            // 検索ワードで投稿内容をハイライトするが、タイトルヒットで表示された1レス目はハイライトしない
            const postContent = (post.content.toLowerCase().includes(keyword.toLowerCase()) || post.author.toLowerCase().includes(keyword.toLowerCase()) || post.userId.toLowerCase().includes(keyword.toLowerCase().replace(/\s/g, '')))
              ? highlightSearchTerm(post.content, keyword)
              : post.content;

            const highlightedAuthor = highlightSearchTerm(post.author, keyword);
            const highlightedUserId = highlightSearchTerm(post.userId, keyword);
            const sageIndicator = post.sage ? ' <span style="color: #888; font-size: 0.9em;">[sage]</span>' : '';
            
            postDiv.innerHTML = `
                <div class="post-meta">
                    <strong>${post.postNumber}: ${highlightedAuthor}</strong>${sageIndicator} | 時刻: ${post.postTime} | ID:${highlightedUserId}
                </div>
                <div class="post-content">${postContent}</div>
            `;
            detailsDiv.appendChild(postDiv);
        });

        headerDiv.addEventListener('click', () => {
            const isHidden = detailsDiv.style.display === 'none' || detailsDiv.style.display === '';
            detailsDiv.style.display = isHidden ? 'block' : 'none';
        });

        threadDiv.appendChild(headerDiv);
        threadDiv.appendChild(detailsDiv);
        resultsDiv.appendChild(threadDiv);
    });
  }

  function searchInThreads(threads, keyword, documentName = null, searchType = 'all') {
    const lowerKeyword = keyword.toLowerCase();
    const searchResults = [];

    // "ID:"で始まるかチェック (スレタイ検索では無効)
    const idSearchMatch = searchType !== 'title' ? keyword.match(/^id:\s*(.*)/i) : null;

    if (idSearchMatch) {
        // ID専用検索 (本文検索 or 全て検索)
        const targetId = idSearchMatch[1].trim().replace(/\s/g, '');
        if (targetId) {
            threads.forEach(thread => {
                const matchedPosts = thread.posts.filter(post => {
                    if (!post.userId) return false;
                    // 文字数によって検索方法を切り替え (大文字小文字を区別)
                    return targetId.length < 4 
                        ? post.userId.startsWith(targetId) 
                        : post.userId.includes(targetId);
                });
                if (matchedPosts.length > 0) {
                    searchResults.push({ ...thread, matchedPosts, documentName });
                }
            });
        }
    } else {
        // 通常検索
        const keywordForIdSearch = lowerKeyword.replace(/\s/g, '');

        threads.forEach(thread => {
            let postsMatchingKeyword = [];
            let titleMatches = false;

            // 検索タイプに応じて検索対象を切り替え
            if (searchType === 'body' || searchType === 'all') {
                postsMatchingKeyword = thread.posts.filter(post => 
                    (post.author && post.author.toLowerCase().includes(lowerKeyword)) ||
                    (post.userId && post.userId.toLowerCase().includes(keywordForIdSearch)) ||
                    (post.content && post.content.toLowerCase().includes(lowerKeyword))
                );
            }

            if (searchType === 'title' || searchType === 'all') {
                titleMatches = thread.title.toLowerCase().includes(lowerKeyword);
            }

            // レスかタイトルのいずれかがヒットした場合
            if (postsMatchingKeyword.length > 0 || titleMatches) {
                let finalMatchedPosts = [...postsMatchingKeyword];

                // タイトルがヒットした場合、1番目のレスがまだ結果に含まれていなければ追加
                if (titleMatches && thread.posts.length > 0) {
                    const firstPost = thread.posts[0];
                    // 既に本文検索でヒットしている場合を除き、先頭に追加する
                    if (!finalMatchedPosts.some(p => p.postNumber === firstPost.postNumber)) {
                        finalMatchedPosts.unshift(firstPost);
                    }
                }
                
                // ヒットした投稿がなければ結果に追加しない
                if (finalMatchedPosts.length > 0) {
                    searchResults.push({ ...thread, matchedPosts: finalMatchedPosts, documentName });
                }
            }
        });
    }

    return searchResults;
  }
  
  function searchPosts() {
    const keyword = document.getElementById('searchInput').value.trim();
    if (!keyword) {
      updateInfoPanel('<span style="color: #c0392b;">検索キーワードを入力してください。</span>');
      return;
    }

    // データが読み込まれていない場合は読み込みを実行
    if (!isDataLoaded) {
      loadDocuments();
      return;
    }

    if (loadedDocumentThreads.size === 0) {
      updateInfoPanel('<span style="color: #c0392b;">データが読み込まれていません。</span>');
      return;
    }

    document.getElementById('results').innerHTML = '<div class="loading">読み込み済みドキュメントを検索中...</div>';
    
    // 少し遅延を入れてUIの更新を確実にする
    setTimeout(() => {
      let searchResults = [];
      const searchType = document.querySelector('input[name="searchType"]:checked').value;
      
      loadedDocumentThreads.forEach((threads, docId) => {
        const docResults = searchInThreads(threads, keyword, docId, searchType);
        searchResults.push(...docResults);
      });

      // 現在の検索結果を保存
      currentSearchResults = searchResults;

      // 選択されたソート順で結果をソート
      const sortOrder = document.querySelector('input[name="sortOrder"]:checked').value;
      const sortedResults = sortSearchResults(searchResults, sortOrder);

      renderSearchResults(sortedResults, keyword);
      updateUrlParams(keyword);
    }, 100);
  }

  function applySorting() {
    if (currentSearchResults.length === 0) return;
    
    const keyword = document.getElementById('searchInput').value.trim();
    const sortOrder = document.querySelector('input[name="sortOrder"]:checked').value;
    const sortedResults = sortSearchResults(currentSearchResults, sortOrder);
    
    renderSearchResults(sortedResults, keyword);
  }
  
  function clearSearch() {
    document.getElementById('searchInput').value = '';
    document.getElementById('results').innerHTML = '<p>検索ボックスにキーワードを入力して検索してください。</p>';
    document.getElementById('searchSummary').style.display = 'none';
    document.getElementById('sortOptions').style.display = 'none';
    currentSearchResults = [];
    updateInfoPanel();
    updateUrlParams('');
  }

  function refreshData() {
    // データをリセット
    loadedDocuments = [];
    loadedDocumentThreads.clear();
    currentSearchResults = [];
    isDataLoaded = false;
    totalDocumentsAvailable = 0;

    // UIをリセット
    document.getElementById('results').innerHTML = '';
    document.getElementById('searchSummary').style.display = 'none';
    document.getElementById('sortOptions').style.display = 'none';
    document.getElementById('documentsList').style.display = 'none';
    document.getElementById('loadStatus').textContent = 'データを再更新しました。検索ボタンを押してデータを読み込んでください。';
    
    updateInfoPanel();
  }

  function updateUrlParams(keyword) {
    const url = new URL(window.location);
    if (keyword) {
      url.searchParams.set('search', keyword);
    } else {
      url.searchParams.delete('search');
    }
    window.history.pushState({}, '', url);
  }

  function checkUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const searchParam = urlParams.get('search');
    if (searchParam) {
      document.getElementById('searchInput').value = searchParam;
      if (isDataLoaded) {
        searchPosts();
      }
    }
  }

  function shareUrl() {
    const shareButton = document.getElementById('shareBtn');
    const originalText = shareButton.textContent;
    const keyword = document.getElementById('searchInput').value.trim();
    
    const url = new URL(window.location);
    // キーワードがあればセット、なければパラメータを削除
    if (keyword) {
      url.searchParams.set('search', keyword);
    } else {
      url.searchParams.delete('search');
    }
    const shareUrl = url.toString();

    navigator.clipboard.writeText(shareUrl).then(() => {
      // 成功したらボタンのテキストを変更し、2秒後に戻す
      shareButton.textContent = 'コピー完了';
      setTimeout(() => {
        shareButton.textContent = originalText;
      }, 2000);
    }).catch(() => {
      // 失敗した場合のフォールバック
      prompt('以下のURLをコピーしてください:', shareUrl);
    });
  }

  // 読み込みモード変更時の処理
  function handleLoadModeChange() {
    const loadMode = document.querySelector('input[name="loadMode"]:checked').value;
    const latestCountInput = document.getElementById('latestCount');
    
    // 最新○件モードの時のみ数値入力を有効化
    latestCountInput.disabled = loadMode === 'all';
  }
  
  // イベントリスナーの設定
  document.getElementById('searchBtn').addEventListener('click', searchPosts);
  document.getElementById('clearBtn').addEventListener('click', clearSearch);
  document.getElementById('docsBtn').addEventListener('click', toggleDocumentsList);
  document.getElementById('shareBtn').addEventListener('click', shareUrl);
  document.getElementById('refreshBtn').addEventListener('click', refreshData);
  document.getElementById('searchInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      searchPosts();
    }
  });

  // ソートオプションの変更イベントリスナー
  document.querySelectorAll('input[name="sortOrder"]').forEach(radio => {
    radio.addEventListener('change', applySorting);
  });

  // 読み込みモードの変更イベントリスナー
  document.querySelectorAll('input[name="loadMode"]').forEach(radio => {
    radio.addEventListener('change', handleLoadModeChange);
  });

  // ブラウザバック/フォワード対応
  window.addEventListener('popstate', checkUrlParams);
  
  // 初期化
  handleLoadModeChange();
  updateInfoPanel();
  
  // 総ドキュメント数だけ先に取得
  fetchTotalDocuments().then(() => {
    const statusText = `全${totalDocumentsAvailable}件のドキュメントが利用可能です。検索ボタンを押してデータを読み込んでください。`;
    document.getElementById('loadStatus').textContent = statusText;
    checkUrlParams();
  });
</script>
</body>
</html>
